// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputePoints
#include "Tables.compute"
#include "NoiseGenerator.compute"

struct Point
{
    float3 pos;
    float value;
};

uint3 dim;
//float3 startPos;
//float3 endPos; 
float3 size;

float3 midPoint; 

float perlinMultiplier; 
float perlinHeight; 

uint shape; 
RWStructuredBuffer<Point> outputPoints;
RWStructuredBuffer<int> CountBuffer;

float dist(float3 a, float3 b)
{
    float x = abs((float1) a.x - b.x) / dim.x;
    float y = abs((float1) a.y - b.y) / dim.y;
    float z = abs((float1) a.z - b.z) / dim.z;
    
    return length(float3(x, y, z));
}

int calculateIndex(int x, int y, int z)
{
    return x + y * (dim.x * dim.z) + z * dim.x; 
}

float getValueCircle(float3 pos)
{
    float averageDim = (dim.x + dim.y + dim.z) / 3;
    float distance = dist(midPoint, pos) * averageDim;
    float value = (distance - (float) averageDim / 2) + 1;
    return (value - (perlinNoise3D(pos.x * perlinMultiplier, pos.y * perlinMultiplier, pos.z * perlinMultiplier) * perlinHeight)) + perlinHeight / 2;
}

float getValuePlane(float3 pos)
{
    float noise = perlinNoise(pos.x * perlinMultiplier, pos.z * perlinMultiplier) * perlinHeight; 
    return ((pos.y - noise) - (perlinHeight + 1));
}

float getValueTube(float3 pos)
{
    if (pos.x > dim.x - 3 || pos.y == dim.y - 3 || pos.z == dim.z - 3)
    {
        return 1;
    }
    float averageDim = (dim.x + dim.y + dim.z) / 3;
    float distance = dist(midPoint, pos) * averageDim;
    float value = (distance - (float) averageDim / 2) + 1;
    float perlin3D = (perlinNoise3D(pos.x * perlinMultiplier, pos.y * perlinMultiplier, pos.z * perlinMultiplier) - 1) / 2 * perlinHeight;
    return -(value - perlin3D) - 2;
}

//float3 offset(uint x, uint y, uint z)
//{
//    float3 val = endPos - startPos; 
//    float xCord = ((float) x / dim.x) * val.x; 
//    float yCord = ((float) y / dim.y) * val.y;
//    float zCord = ((float) z / dim.z) * val.z;
//    return float3(xCord, yCord, zCord); 
//}


[numthreads(8,8,8)]
void ComputePoints(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= dim.x || id.y >= dim.y || id.z >= dim.z)
    {
        return;
    }
    
    
    
    float3 pos = float3(id.x, id.y, id.z); //+ offset(id.x, id.y, id.z); 
    float value;
    if (shape == 0)
    {
        value = getValueCircle(pos);
    } 
    else if (shape == 1)
    {
        value = getValuePlane(pos);
    }
    else
    {
        value = getValueTube(pos);
    }
    
    
    pos = pos * size;
    
    Point p;
    p.pos = pos;
    p.value = value;
    
    outputPoints[calculateIndex(id.x, id.y, id.z)] = p;
    InterlockedAdd(CountBuffer[0], 1);
}
